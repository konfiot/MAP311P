\documentclass[a4paper,12pt,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[titlepage,fancysections,pagenumber]{polytechnique}
\usepackage{amsfonts} \usepackage{amsmath} \usepackage{graphicx} 
\usepackage{pgf}
\usepackage{pgf,tikz}
\usepackage{mathrsfs}
\usetikzlibrary{arrows}
\usetikzlibrary[patterns]

\newcommand{\p}{\mathbb{P}}
\title{Rapport de projet python MAP311}
\subtitle{Enveloppes convexes aléatoires}
\author{David Cheikhi et Arthur Toussaint}

\begin{document}

\maketitle

\section{Des polygones engendrés par l'enveloppe convexe de $n$ points aléatoires}
\section{Une borne théorique inférieure}
	\begin{enumerate}
		\item Je sais pas trop si la réponse attendue est une réponse intuitive ou une vraie démonstration de probas
		\item \label{extr} Si P est extrémal, alors P est nécessairement un des sommets du polygone, on a donc $C_n \subset B_n$ ce qui implique que $\p(B_n) \geq \p(C_n)$
		\item En introduisant $S(r)$ l'aire du cercle de rayon $r$, on à
		\begin{eqnarray}
			\p(C_n) &=& \int_0^1{\p(C_n | R = r) \p(r\leq R \leq r + dr)} \\
				&=& \int_0^1{\p(P_1 \not\subset S_p \cap \ldots \cap P_{n-1} \not\subset S_p)\p(r\leq R \leq r + dr)} \\
				&=& \int_0^1{\p(P_1 \not\subset S_p) \ldots \p(P_{n-1} \not\subset S_p)\p(r\leq R \leq r + dr)} \\
				&=& \int_0^1{\p(P_1 \not\subset S_p)^{n-1}\p(r\leq R \leq r + dr)} \\
				&=& \int_0^1{(1 - \p(P_1 \subset S_p))^{n-1}\p(r\leq R \leq r + dr)} \\
				&=& \int_0^1{\left( 1 - \frac{g(r)}{\pi}\right) ^{n-1}\p(r\leq R \leq r + dr)} \\
				&=& \int_0^1{\left( 1 - \frac{g(r)}{\pi}\right) ^{n-1}\frac{S(r + dr) - S(r)}{S(1)}} \\
				&=& \int_0^1{\left( 1 - \frac{g(r)}{\pi}\right) ^{n-1}\frac{\frac{dS}{dr}dr}{\pi}} \\
				&=& \int_0^1{\left( 1 - \frac{g(r)}{\pi}\right) ^{n-1}\frac{2\pi r dr}{\pi}} \\
				&=& \int_0^1{\left( 1 - \frac{g(r)}{\pi}\right) ^{n-1}2 r dr} \\
		\end{eqnarray}
		\item
			\begin{figure}
			\centering
			\caption{Schéma Q4}
			\label{fig:q4}
			\definecolor{ffqqqq}{rgb}{1.,0.,0.}
			\definecolor{qqttff}{rgb}{0.,0.2,1.}
			\definecolor{uququq}{rgb}{0.25098039215686274,0.25098039215686274,0.25098039215686274}
			\begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=5.0cm,y=5.0cm]
			\clip(-1.2,-1.2) rectangle (1.2,1.2);
			\fill[line width=0.pt,color=ffqqqq,fill=ffqqqq,pattern=north east lines,pattern color=ffqqqq] (-0.4358898943540673,0.) -- (-0.4358898943540673,0.9) -- (0.43588989435406733,0.9) -- (0.43588989435406733,0.) -- cycle;
			\draw [line width=0.8pt] (0.,0.) circle (5.cm);
			\draw [line width=0.8pt,dash pattern=on 2pt off 2pt] (-0.4358898943540673,0.9)-- (0.43588989435406733,0.9);
			\draw [line width=0.8pt,domain=-1.2:1.2] plot(\x,{(-0.-0.*\x)/1.});
			\draw [line width=0.8pt,dash pattern=on 2pt off 2pt] (-0.4358898943540673,0.)-- (-0.4358898943540673,0.9);
			\draw [line width=0.8pt,dash pattern=on 2pt off 2pt] (0.43588989435406733,0.9)-- (0.43588989435406733,0.);
			\draw [shift={(0.,0.)},line width=0.8pt,color=qqttff,fill=qqttff,pattern=north east lines,pattern color=qqttff]  plot[domain=1.1197695149986342:2.0218231385911594,variable=\t]({1.*1.*cos(\t r)+0.*1.*sin(\t r)},{0.*1.*cos(\t r)+1.*1.*sin(\t r)}) -- cycle ;
			\begin{scriptsize}
			\draw [fill=uququq] (-0.4358898943540673,0.9) circle (1.5pt);
			\draw[color=uququq] (-0.4117690554175289,0.9488112808172411) node {$C$};
			\draw [fill=uququq] (0.43588989435406733,0.9) circle (1.5pt);
			\draw[color=uququq] (0.4585375073878903,0.9488112808172411) node {$D$};
			\draw [fill=uququq] (-0.4358898943540673,0.) circle (1.5pt);
			\draw[color=uququq] (-0.4717690554175292,0.04826240501858345) node {$E$};
			\draw [fill=uququq] (0.43588989435406733,0.) circle (1.5pt);
			\draw[color=uququq] (0.4685375073878903,0.04826240501858345) node {$F$};
			\draw[color=qqttff] (-0.04046065700054505,1.0916222032853118) node {$S_p$};
			\draw[color=ffqqqq] (0.51666371198668324,0.49013620041979045) node {$S_b$};
			\end{scriptsize}
			\end{tikzpicture}
			\end{figure}
			On cherche tout d'abord les bornes de l'intervalle d'integration. On utilise pour cela la Figure \ref{fig:q4}

			Pour trouver l'aire voulue, on doit integrer entre $x_c$ et $x_d$, ces points sont les points d'intersection entre la droite d'équation $y = r = 1 - s$ et le cercle d'équation $x^2 + y^2 = 1$
			$$ \sqrt{1 - x^2} = y = 1 - s $$ donc 
			\begin{eqnarray}
				x^2	&=& (1 - s)^2 + 1\\
					&=& 1 + 2s - s^2 + 1\\
					&=& 2s - s^2
			\end{eqnarray} 
			donc $x = \pm \sqrt{2s - s^2}$

			On cherche ensuite à déterminer $S_p$, on calcule donc $S_p + S_b - S_b$
			Ainsi, \begin{eqnarray}
				h(s)	&=& S_p \\
					&=& S_p + S_b - S_b \\
					&=& \int^{\sqrt{2s - s^2}}_{-\sqrt{2s - s^2}}{\sqrt{1-x^2}dx} - \int^{\sqrt{2s - s^2}}_{-\sqrt{2s - s^2}}{(1 - s) dx} \\
					&=& \int^{\sqrt{2s - s^2}}_{-\sqrt{2s - s^2}}{(s + \sqrt{1-x^2} - 1) dx}
			\end{eqnarray}

		\item on a $$\sqrt{1 - x^2} = 1 - \frac{x^2}{2} + o(x^2)$$
		donc
		\begin{eqnarray}
			h(s)	&=& \int^{\sqrt{2s - s^2}}_{-\sqrt{2s - s^2}}{(s - \frac{x^2}{2} + o(x^2)) dx} \\
				&=& 2s^{3/2}\sqrt{2-s} - \frac{1}{3}(2s - s^2)^{3/2} + o(2s-s^2)^3 \\\text{Vrai car $ \lim_{x \to 0} 2s - s^2 = 0$}\\ % TODO : Rajouter que c'est vrai car x tend vers 0 quand 2s^2 - s^2 tend vers 0
				&\sim& s^{3/2} (2\sqrt{2-s} - \frac{1}{3}(2 - s)^{3/2}) \\
				&\sim& s^{3/2} (2\sqrt{2} - \frac{1}{3}\sqrt{8}) \\
				&\sim& s^{3/2} \sqrt{2}(2 - \frac{1}{3}\sqrt{4}) \\
				&\sim& s^{3/2} 2\sqrt{2}(1 - \frac{1}{3}) \\
				&\sim& s^{3/2} \frac{4\sqrt{2}}{3} \\
		\end{eqnarray}
		\item	Si $h(s) << \frac{1}{n}$, $\left(1 - \frac{h(s)}{\pi}\right)^{n-1}$ tend vers $0$, et si $h(s) >> \frac{1}{n}$, cette quantité diverge, il faut donc avoir $h(s) \sim \frac{1}{n}$ ce qui implique que $s \sim un^{-2/3}$% TODO ; Mieux démontrer ça

		\item Dans ce cas, on a bien $\left(1 - \frac{h(s)}{\pi}\right)^{n-1}$ qui tend vers $e^{-\frac{K}{\pi}u^{3/2}}$

		De plus, on a bient $2(1-s) \sim 2n^{-2/3}$

		\end{enumerate}

\section{Simulations}
	\subsection{Tirer des points au hasard dans le disque unité}
		On observe des différences dans la distribution des points. On voir que dans le premier cas, la densité des points augmente au fur et à mesure que l'on se rapproche du centre. En effet, on comprend intuitivement que l'on a autant de chances qu'un point se retrouve dans une bande comprise entre les rayons $r$ et $r + dr$ quel que soit r, mais que la surface de cette bande croît avec r, ainsi, la densité est plus élevée en moyenne quand $r$ tend vers $0$ les deux méthodes suivantes semblent donner des points répartis uniformément sur le disque.
		Afin de séparer ces deux dernières méthodes, on prendra donc la plus efficace. Une mesure du temps de calcul de ces trois méthodes sur une génération de 600 points avec 600 répétitions donne le résultat suivant (fichier gen.py) : 
		\begin{verbatim}T1 = 0.24763862291971842 ms (std.dev. 0.0098647314503971)
T2 = 0.8399013678232828 ms (std.dev. 0.07227058109796747)
T3 = 0.4730105400085449 ms (std.dev. 0.023126789901638765)
\end{verbatim}
		On remarque que la troisième méthode est significativement plus rapide que la seconde, et constitue ainsi le candidat qui réalise à la fois les contraintes indispensables (répartition uniforme des points sur le cercle) et qui minimise le temps de calcul. Nous retenons donc cette méthode de tirage afin de réaliser les essais ultérieurs.

		De plus, la première méthode est plus rapide que la troisième seulement car elle n'effectue pas la projection des coordonnées polaires générées en coordonnées cartésiennes, une fois cette conversion effectuée, les méthodes un et trois retrouvent un temps de calcul comparable, ce qui met encore plus en valeur le choix précédement exprimé.

	\subsection{Trouver l'enveloppe convexe de $n$ points}

		L'idée de cet algorithme est de partir d'un point extremal, qu'on sait appartenir à l'enveloppe convexe (question \ref{extr}), puis de tourner autour de la figure, le fait de tourner dans le même sens garantira la convexité de l'enveloppe. on parcourera les points en partant du point le plus a gauche et en parcourant les points dans le sens trigonométrique par rapport au point d'origine lors de ce parcours, on ajoutera les points au fur et à mesure dans la pile qui définira l'enveloppe convexe, si un point effectue un virage à droite, on éliminera un a un les points de la pile jusqu'à ce que le virage entre le nouveau point et le haut de la pile se fasse à gauche. les points éliminés entre le haut de la pile et le point en cours de considération étant contenus dans l'enveloppe engendrée par les points contenus dans la pile et les points encore non considérés.  

		On a donc un invariant de boucle qui est : "Tous les points sont contenus dans l'enveloppe engendrée par l'union des points présents dans la pile avec les points encore non considérés, et l'enveloppe engendrée par les points présents sur la pile est convexe" 

		Ainsi, après avoir parcouru tous les points, il ne reste plus aucun point encore non considéré, l'invariant de boucle devient donc à la fin du parcours, "Tous les points sont contenus dans l'enveloppe engendrée par les points sur la pile, et cette enveloppe est convexe" ce qui correspond bien au résultat attendu

		Nous venons de décrire de façon intuitive l'algoritheme qui permettra de résoudre notre problème, mais il reste encore à définir plus rigoureusement ce que signifie "Tourner a gauche/droite" et "Effectuer un parcours dans le sens trigonométrique"

		Commençons par définir "Effectuer un parcours dans le sens trigonométrique". Pour cela, il nous faut trier les points selon un critère précis. D'un point de vue algorithmique, cette opération prendra $O(n\ln n)$ opération, en supposant que l'opération de comparaison prend un temps constant, ce que nous vérifierons par la suite. Le choix des mots suggère ici de calculer un angle pour chaque point, et de comparer les angles de chaque point. Une première idée est d'associer a chaque point des coordonnées $(x, y)$ le complexe $z = x + iy$ et de calculer pour chacun de ces points la différence entre l'argument du complexe associé à ce point et l'argument du complexe associé au point extrémal choisi au début. Cette valeur marche dans la plupart des cas, mais ne fonctionne pas dans le cas ou l'origine ne se trouve pas à l'intérieur de l'ensemble des points tirés (Ce qui est un évènement de probabilité exponentiellement décroissante). On pourrait alors considérer de calculer en premier lieu le barycentre de l'ensemble de ces points et de prendre ce barycentre comme origine.

		Il existe néanmoins une méthode plus élégante qui ne nécessite pas de calculer un tel point (Calcul de complexité $O(n)$ qui ne rallonge pas asymptotiquement le temps d'execution de l'algorithme mais qui constitue un cout évitable). On va trier les points selon la pente que forme la droite passant par le point extremal et ce point. Afin d'éviter d'avoir des valeurs infinies, on utilisera la fonction atan2(x,y) qui calcule l'arctangente de $\frac{x}{y}$ et renvoie $\pm \frac{\pi}{2}$ si $y = 0$, selon le signe de $x$, et nous permet donc de classer même les points à la verticale du point extremal

		Afin de définir "Tourner à droite" et "Tourner à gauche", on peut reformuler le problèmes en termes marins, on veut savoir si le point C est à babord ou a tribord du bateau modélisé par le vecteur AB, pour cela, on utilise le déterminan de ces trois vecteurs, dont le signe discrimine ces deux états.

		Il est alors pertinent de se demander si un tel algorithme peut être généralisé en dimension plus grande, quand les points tirés ne sont pas dans le plan, mais dans l'espace, l'hyperespace, ou dans un espace de dimension n.



	\subsection{Le vif du sujet}
		Afin d'estimer $\varepsilon_n$, on effectue pour chaque $n$ plusieurs tirages (On à choisi ici 100 qui constitue un bon compromis entre qualité des résultats et vitesse de calcul), on calcule l'enveloppe convexe de ce tirage et on retient la moyenne du nombre de sommet de l'enveloppe convexe comme valeur estimée de $\varepsilon_n$

		L'implémentation d'un tel estimateur (fichier main.py) permet de tracer le graphe Figure~\ref{fig:exp_cercle}, ainsi que de calculer la courbe de la forme $kn^{1/3}$ qui approche au mieux les données expérimentales.

		\begin{figure}[htpb]
			\centering
			\input{fig_exp_cercle.pgf}
			\caption{Données expérimentales}
			\label{fig:exp_cercle}
		\end{figure}

		On peut alors se demander, comme le sujet le suggère, comment varie cette loi quand on tire ces points non plus dans un disque, mais dans un polygone régulier.
		Pour effectuer cette expérience, on garde l'algorithme de graham, mais on modifie le générateur de nombre aléatoires. Pour pouvoir tirer des points uniformément dans un polygone, on procède de la manière suivante : On tire aléatoirement une "tranche" $i$, c'est à dire un nombre entre $0$ et $k-1$ ou $k$ représente le nombre de sommets du polygone régulier choisi, puis on génère un nombre qui se trouvera dans le triangle composé de l'origine, du point d'affixe $e^{2ij\pi/k}$ et du point d'affixe $e^{2i(j+1)\pi/k}$
		Pour générer un point dans ce triangle, on génère un point dans le parallélogramme associé à ce triangle, puis on prend calcule ses coordonnées dans le triangle dans lequel ce point se trouve. 
		On trace alors le graphe Figure~\ref{fig:exp_poly}, et calculer la constante qui va miniser la somme des résidus quadratiques. (L'exemple utilise un pentagone)

		\begin{figure}[htpb]
			\centering
			\input{fig_exp_poly.pgf}
			\caption{Données expérimentales}
			\label{fig:exp_poly}
		\end{figure}

		On peut ensuite se demander comment varie la constante $c$ en fonction du nombre de sommets du polygone considéré. Intuitivement, on peut alors penser qu'en faisant tendre le nombre de points vers l'infini, notre polygone va converger uniformément vers un cercle, et qu'ainsi, on devrait retrouver asymptotiquement le comportement que l'on à avec un cercle. Cette convergence implique aussi une forme de stabilisation de $c$, car les contributions en aire apportés par les polygones de plus grand nombre de sommets deviennent de plus en plus petites.

		En calculant des regressions permettant d'estimer $c$ pour différents polygones, en tirant toujours le même nombre de points ($1000$), on trace le graphe Figure~\ref{fig:exp_c}

		\begin{figure}[htpb]
			\centering
			\input{fig_exp_c.pgf}
			\caption{Estimation de $c$}
			\label{fig:exp_c}
		\end{figure}

		On trouve bien que $c$ tend vers une valeur constante.


\end{document}

